function showSection(id) {
  document.querySelectorAll('main section').forEach(sec => sec.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

// Setup scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("dataFlow"), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(0, 5, 5);
scene.add(pointLight);

// Create flowing particles
const colors = [0xffcc00, 0xff00ff, 0x6600ff, 0x00ccff]; 
const particleCount = 800;
let particles = [];

for (let i = 0; i < particleCount; i++) {
    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
    const material = new THREE.MeshStandardMaterial({
        color: colors[Math.floor(Math.random() * colors.length)],
        emissive: 0x222222,
        emissiveIntensity: 0.8,
        metalness: 0.2,
        roughness: 0.3
    });

    const particle = new THREE.Mesh(geometry, material);

    particle.userData = {
        angle: Math.random() * Math.PI * 2,
        radius: 4 + Math.random() * 2,
        speed: 0.01 + Math.random() * 0.02,
        height: Math.random() * 4 - 2,
        offset: Math.random() * 360
    };

    scene.add(particle);
    particles.push(particle);
}

camera.position.z = 8;

// Animation loop
function animate() {
    requestAnimationFrame(animate);

    particles.forEach(p => {
        p.userData.angle += p.userData.speed;
        p.position.x = Math.cos(p.userData.angle) * p.userData.radius;
        p.position.y = Math.sin(p.userData.angle * 2) * 0.5 + p.userData.height;
        p.position.z = Math.sin(p.userData.angle) * p.userData.radius;

        p.rotation.x += 0.02;
        p.rotation.y += 0.02;
    });

    camera.position.x = Math.sin(Date.now() * 0.0005) * 2;
    camera.position.y = Math.sin(Date.now() * 0.0003) * 1;
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
function showSection(id) {
  document.querySelectorAll('main section').forEach(sec => {
    sec.classList.remove('active');
  });

  const target = document.getElementById(id);
  target.classList.add('active');

  // Trigger animation for contact section
  if (id === 'contact') {
    target.style.opacity = "0"; // reset
    setTimeout(() => {
      target.style.opacity = "1";
      target.classList.add("active");
    }, 50);
  }
}
// =========================
// MOUSE PARTICLE TRAIL
// =========================
const trailCanvas = document.getElementById("mouseTrail");
const tCtx = trailCanvas.getContext("2d");

function resizeTrailCanvas() {
  trailCanvas.width = window.innerWidth;
  trailCanvas.height = window.innerHeight;
}
resizeTrailCanvas();
window.addEventListener("resize", resizeTrailCanvas);

// Particle array
let trailParticles = [];

class TrailParticle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 4 + 2;
    this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
    this.life = 1; // 1 = fully visible
  }

  update() {
    this.y -= 0.5; // slight upward drift
    this.x += (Math.random() - 0.5) * 2;
    this.size *= 0.96; // shrink
    this.life -= 0.02; // fade out
  }

  draw() {
    tCtx.beginPath();
    tCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    tCtx.fillStyle = this.color;
    tCtx.globalAlpha = this.life;
    tCtx.fill();
    tCtx.globalAlpha = 1;
  }
}

// Handle mouse move
document.addEventListener("mousemove", (e) => {
  for (let i = 0; i < 3; i++) {
    trailParticles.push(new TrailParticle(e.clientX, e.clientY));
  }
});

function animateTrail() {
  tCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);

  trailParticles.forEach((p, index) => {
    p.update();
    p.draw();
    if (p.life <= 0 || p.size < 0.5) {
      trailParticles.splice(index, 1);
    }
  });

  requestAnimationFrame(animateTrail);
}

animateTrail();
